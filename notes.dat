Classes encapsulate properties and operations in one entity. Classes have members: member variables (or fields) and
member methods.

In OOP dynamic behaviour (methods) is subordinated to structure (classes).

The body of a class may have the fallowing members:
- member variables and constants
- member methods
- nested classes
- interfaces
- constructors
- instance initializers
- static initializer

Constructors return nothing. Constructors may throw exceptions. Constructors may be overloaded as normal methods do.

Only if we don't supply some constructor explicitly, the compiler will create a default constructor which has no
arguments (parameterless constructor) and just allocates memory for the object. It's called the default constructor.
This default constructor will implicitly call the parameterless constructor of the superclass. Therefore if, for example,
ClassB extends ClassA, and ClassA has not a parameterless constructor, Classb will not be allowed to have a parameterless
constructor either, not even that inserted by the compiler by default.

The default (parameterless) constructor inserted by the compiler will have the same access modifier as its class.

Every constructor that doesn't call another constructor in the same class (using this(...) ) has a call to its parent
constructor, whether it was written explicitly or inserted by the compiler through super(). Similarly, if a class does not
explicitly extends another class, the compiler makes it extend class "Object".

Constructors in a class need to have the appropriate access modifiers (as for member methods, public,protected, private,
default) if we want to instantiate
object of this class with 'new'. For example, if a constructor has no explicit access modifier, it will have 'default'
by omission. This means that such constructor will only be visible inside the same package as where the class is defined.
Therefore, even if the class is public, outside this package we'll not be able to instantiate this class, although we'll
be able to use its type as a reference, cuz it's a public class.

We might define a member method with the same name as the class, as constructor do, though this would create confusion.

Instance and class variables don't require us to initialize them. As soon as we declare these variables,
they are given a default value as follows:
boolean: false
byte, short, int, long: 0
float, double: 0.0
char: '\u0000'
reference type: null

Local variables (variables defined inside a method) must be initialized before use, otherwise the compiler will not let
us use them.
Constants in Java are defined by means of the 'final' keyword. This keyword makes the variable's value unmodified after
it was first set. Member variables with the 'final' modifier must be initialized either when declared or in the class
constructor(s). Eg:

private static final int YEAR = 2000;

In Java, an initializer is a block of code that has no associated name or data type and is placed outside of any
method, constructor, or another block of code. There are two types of initializers: instance initializers and
static initializer.

Instance initializers initializes instance variables. It may contain expressions as well.
A static initializer initializes static fields.

When an instance is initialized, at the very beginning of any constructor body the following steps are executed only
once:
1. the JVM initializes the fields with default values (eg, 0 for integer primitives)
2. instance variable initializers are executed
3. instance initializer block is executed

These steps are preceded only by the invocation to another constructor of the class, using keyword 'this', if such
instruction exists in the constructor body. If the new constructor we landed doesn't contain any this() call to another
constructor, the mentioned steps will be executed in that order.

(See Pellegrino Principe "Flusso elaborativo di creazione di un'instanza p. 262").

WE CAN COMPILE A CLASS AND THEN DECOMPILE ITS .CLASS TO SEE WHAT THE COMPILER WILL ACTUALLY UNDERSTAND FROM WHAT WE CODED !!!

Therefore, in the constructor we can actually use variables initialized in the instance initializer:

class ClassA{
    private int x = 33;  // the expression 33 is an instance variable initializer
    private int y;
    private int z;

    // this is an instance initializer block. It is executed only once, when and instance is created. It may contain
    // expression as well
    {
        x = 55;
        y = 88;
        z = x + y + foo();
    }

    ClassA(int x) {
        // variable z was set in the instance initializer
        this.x = x + z;
    }

    private int foo(){
        return 100;
    }
}

Instance initializer blocks are very useful to isolate, and write only once, the initializations of some class fields,
which all constructors in the class need to initialize. Without such possibility, we would need to initialize these
field in all the constructors, thus duplicating code.

<<Class>>

See https://www.baeldung.com/java-initialization for an explanation of the fundamental difference between primitive types
and reference types in Java:
"Unlike primitive types that hold their values in the memory where the variable is allocated, references don't hold the
value of the object they refer to. Instead, a reference points to an object by storing the memory address where the
object is located."

The reference will be stored in an area of memory called the "stack", whereas the object it points to will be stored in
another area of memory called the "heap" (or managed heap). Primitive types will be stored in the stack directly.

Class modifiers can be:
- access modifiers:
    - public: in/out package visibility
    - protected: in package visibility plus out package only for subclasses
    - default: in package visibility only (but we don't write down 'default' in our code, it's meant by omission)
    - private (only of inner or nested classes)
- abstract
- static (only for static-nested classes). See https://www.baeldung.com/java-static
- final: makes the class non extendable
- strictfp

Class members (fields and methods) have the same access modifiers as written above, with the same meanings. Class members
are always accessible from the body of the same class without qualification. The only exception is static methods, which
can only access other static members (fields and methods).

Inside a class, all its members have class-body visibility, they can be accessed directly in that scope. Variables inside
a method or a black {} have, instead, method or block visibility only. If with the same name, the latter can shadow
class instance variables, making us need the keyword 'this' to be able to refer to the shadowed variables.

Getters and Setters if private fields allow for further checks when a private field wants to be set or read from a
client code. For example, a setter might check for the validity of the value we want to set, whereas a getter might check
for read access permissions.

Static members, p. 268
Static members can be either variables or methods. They are called "class variables" and "class methods".

Static methods of a class cannot access non-static members of the class (fields and methods), because from a class body
class members are actually invoked by the compiler prepending "this." to the call, as we know, in this case there is
no object 'this' can refer to. For this reason we cannot use either 'this' or 'super', in a static method.

A .java file can at most contain one public class, and it must have the same name as the file.

A class toString() method will always overwrite such method from its superclass (which will be Object if nothing is
specified). This method must return a String, and will always be invoked whenever an identifier of an instance of the
class is used alone (without following with the . operator). If we do not overwrite the toString() method, its
definition from the Object class will be used, which will print in the format package_name.type_name@hex_hash_code

In the body of constructors or methods of a class, private fields of an instance of the same class type received as
argument can be accessed directly. In other words, private members (not only fields) are private to the type, not to
an instance of that type.

<<Class finalizer>>

Besides class constructors, in Java we have class finalizers. A class finalizer defines a set of actions to be taken
before an instance of a class is deleted by the Java garbage collector. A typical example is to close a file stream
previously opened when the instance was created (free resources).

The garbage collector is invoked to free the memory occupied by a class instance, when we cannot longer refer to it.
We cannot call the Java garbage collector explicitly.

We can call a class's finalizer explicitly (provided its access modifiers allow so), but it will be called by the
garbage collector as well, just that we cannot know when. The finalizer always overwrite that of the class's superclass.

The syntax of a finalizer is equal to that of any normal method, but it must be called "finalize" eg.:
@Override
public void finalize() { ... }

We should NEVER use finalizers though. There are several drawbacks to finalizers. A preferred alternative is to make
our class implement the AutoCloseable interface and overwrite the close() method.
See https://www.baeldung.com/java-finalize for a though and clear explanation of finalizers.

In fact, finalize() method has been deprecated starting with Java 9 â€“ and will eventually be removed.

<<this>>

Whenever an object is instantiated, a special pointer to it is created. This pointer will be called "this" and can only
be used in the body of constructors, instance methods, default methods, instance initializers and instance variables
initializers, always of the class type of the object. It can't be used in static methods or static initializers,
because these exist only at class level.

When we directly access members of a class from the body of its constructors or methods, the compiler actually prepends
"this." to our call. We can do it explicitly as well, as when we pass to a constructor arguments named after some
fields of the class. Eg:

class ClassA{
    private int x;

    ClassA(int x) {this.x = x;}
}

This is an example of "hiding through nesting" or shadowing: the identifiers 'x' inside the constructor will be in an
"inner scope" and will "shadow" the identifier x in the class fields, which will be in an "outer scope". It may happen
between the body class and any of its methods body (a constructs is just a special method). In this case, access to
the identifier of the outer scope will be possible only using the keyword 'this'.

The keyword 'this' allows for a very common pattern where we call different methods or constructors of a class in
cascade, to separately set some of its fields eg:
class ClassA {
    private int x;
    private int y;

    public ClassA setX(int x){
        this.x = x;
        return this;
    }
    public ClassB setY(int y){
        this.y = y;
        return this;
    }
}

//in the main()
ClassA ca = new ClassA()
System.out.println(ca.setX(3).setY(y));

When we use 'this' inside a constructor to call another constructor of the class, such instruction must be the first
in the constructor body. The following is a very common example, where we make converge the overloaded constructors of
a class into a single one that concentrates the logic. This also helps avoiding code duplication in the overloaded
constructors:

class MyTime{
    int h; int m; int s;

    public MyTime() {
        this (0, 0, 0);
    }
    public MyTime(int h) {
        this (h,0,0);
    }
    public MyTime(int h, int m) {
        this (h,m,0);
    }

    public MyTime(int h, int m, int s) {
        this.h = h;
        this.m = m;
        this.s = s;
    }
}

