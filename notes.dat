Classes encapsulate properties and operations in one entity. Classes have members: member variables (or fields) and
member methods.

In OOP dynamic behaviour (methods) is subordinated to structure (classes).

The body of a class may have the fallowing members:
- member variables and constants
- member methods
- nested classes
- interfaces
- constructors
- instance initializers
- static initializer

Constructors return nothing. Constructors may throw exceptions. Constructors may be overloaded as normal methods do.

Only if we don't supply some constructor explicitly, the compiler will create a default constructor which has no
arguments (parameterless constructor) and just allocates memory for the object. It's called the default constructor.
This default constructor will implicitly call the parameterless constructor of the superclass. Therefore if, for example,
ClassB extends ClassA, and ClassA has not a parameterless constructor, Classb will not be allowed to have a parameterless
constructor either, not even that inserted by the compiler by default.

The default (parameterless) constructor inserted by the compiler will have the same access modifier as its class.

Every constructor that doesn't call another constructor in the same class (using this(...) ) has a call to its parent
constructor as super(), (ie. the parameterless constructor of the super class), whether it was written explicitly or
inserted by the compiler. If the parameterless constructor of the super class is not accessible, eg. it is provate,
we'll get an error.
Similarly, if a class does not explicitly extends another class, the compiler makes it extend class "Object".

Constructors in a class need to have the appropriate access modifiers (as for member methods, public,protected, private,
default) if we want to instantiate
object of this class with 'new'. For example, if a constructor has no explicit access modifier, it will have 'default'
by omission. This means that such constructor will only be visible inside the same package as where the class is defined.
Therefore, even if the class is public, outside this package we'll not be able to instantiate this class, although we'll
be able to use its type as a reference, cuz it's a public class.

We might define a member method with the same name as the class, as constructor do, though this would create confusion.

Instance and class variables don't require us to initialize them. As soon as we declare these variables,
they are given a default value as follows:
boolean: false
byte, short, int, long: 0
float, double: 0.0
char: '\u0000'
reference type: null

Local variables (variables defined inside a method) must be initialized before use, otherwise the compiler will not let
us use them.
Constants in Java are defined by means of the 'final' keyword. This keyword makes the variable's value unmodified after
it was first set. Member variables (fields) with the 'final' modifier must be initialized either when declared in the
class or in initialization blocks, or in the class constructor(s). Eg:

private static final int YEAR = 2000;

Fields with the 'final' modifier will be constants, and it makes no sense to have a copy of them for each instance.
Therefore they are usually also declared 'static'.

In Java, an initializer is a block of code that has no associated name or data type and is placed outside of any
method, constructor, or another block of code. There are two types of initializers: instance initializers and
static initializer.

Instance initializers initializes instance variables. It may contain expressions as well.
A static initializer initializes static fields.

A static field is a pointer to a common memory location that all instance of that class will have. Static fields are
also initialize with default values by the compiler, as normal class fields are.

When an instance is initialized, at the very beginning of any constructor body the following steps are executed only
once:
1. the JVM initializes the fields with default values (eg, 0 for integer primitives)
2. instance variable initializers are executed
3. instance initializer block is executed

These steps are preceded only by the invocation to another constructor of the class, using keyword 'this', if such
instruction exists in the constructor body. If the new constructor we landed doesn't contain any this() call to another
constructor, the mentioned steps will be executed in that order.

*** (See Pellegrino Principe "Flusso elaborativo di creazione di un'instanza p. 262, p. 274"). ***

WE CAN COMPILE A CLASS AND THEN DECOMPILE ITS .CLASS TO SEE WHAT THE COMPILER WILL ACTUALLY UNDERSTAND FROM WHAT WE CODED !!!

The first time (only the first time) we call a constructor or a static method of a class having a static initializer
block, the call will trigger the execution of this block first; then the body of the constructor or the static method
will be executed. The same is true for an assignment to a static field, it will trigger the static initializer block.

It seems this block is also executed when we assign a value to a static member...


Therefore, in the constructor we can actually use variables initialized in the instance initializer:

class ClassA{
    private int x = 33;  // the expression 33 is an instance variable initializer
    private int y;
    private int z;

    // this is an instance initializer block. It is executed only once, when and instance is created. It may contain
    // expression as well
    {
        x = 55;
        y = 88;
        z = x + y + foo();
    }

    ClassA(int x) {
        // variable z was set in the instance initializer
        this.x = x + z;
    }

    private int foo(){
        return 100;
    }
}

Instance initializer blocks are very useful to isolate, and write only once, the initializations of some class fields,
which all constructors in the class need to initialize. Without such possibility, we would need to initialize these
field in all the constructors, thus duplicating code.

A field of a class can be another class. If this class field is a class in the same package as the class were it
figures, then we'll not need to import it; its compiled .class file will be in the same directory as that of our current
class and both the compiler and the JVM will find it.

When a class contains another class as field, we say there is a "composition" or a "has-a" relation.

<<Class>>

See https://www.baeldung.com/java-initialization for an explanation of the fundamental difference between primitive types
and reference types in Java:
"Unlike primitive types that hold their values in the memory where the variable is allocated, references don't hold the
value of the object they refer to. Instead, a reference points to an object by storing the memory address where the
object is located."

The reference will be stored in an area of memory called the "stack", whereas the object it points to will be stored in
another area of memory called the "heap" (or managed heap). Primitive types will be stored in the stack directly.

Class modifiers can be:
- access modifiers:
    - public: in/out package visibility
    - protected: in package visibility plus out package only for subclasses
    - default: in package visibility only (but we don't write down 'default' in our code, it's meant by omission)
    - private (only of inner or nested classes)
- abstract
- static (only for static-nested classes). See https://www.baeldung.com/java-static
- final: makes the class non extendable
- strictfp

Class fields modifiers can be (p. 270):
- access modifiers:
    - public
    - protected
    - private
    - default
- final
- static
- transient
- volatile

Class methods can have the modifiers (p. 271):
- access modifiers
    - public
    - protected
    - private
- final
- static
- abstract
- synchronized
- native
- strictfp

     	         private  default	protected	public
Class	         No	      Yes	    No      	Yes
Nested Class	 Yes	  Yes   	Yes     	Yes
Constructor	     Yes      Yes   	Yes     	Yes
Method	         Yes	  Yes	    Yes     	Yes
Field        	 Yes	  Yes	    Yes      	Yes

Class members (fields and methods) have the same access modifiers as written above, with the same meanings. Class members
are always accessible from the body of the same class without qualification. The only exception is static methods, which
can only access other static members (fields and methods).

Inside a class, all its members have class-body visibility, they can be accessed directly in that scope. Variables inside
a method or a block {} have, instead, method or block visibility only. If with the same name, the latter can shadow
class instance variables, making us need the keyword 'this' to be able to refer to the shadowed variables.

Getters and Setters if private fields allow for further checks when a private field wants to be set or read from a
client code. For example, a setter might check for the validity of the value we want to set, whereas a getter might check
for read access permissions.

Static members, p. 268
Static members can be either variables or methods. They are called "class variables" and "class methods".

Static methods of a class cannot access non-static members of the class (fields and methods), because from a class body
class members are actually invoked by the compiler prepending "this." to the call, as we know, in this case there is
no object 'this' can refer to. For this reason we cannot use either 'this' or 'super', in a static method.
However, constructors, which cannot be static, can access static members.

Static fields can also be final. Moreover, final class fields are usually declared as static, since it doesn't make sense
to have a copy of them for each instance as they are constants.

A .java file can at most contain one public class, and it must have the same name as the file.

A class toString() method will always overwrite such method from its superclass (which will be Object if nothing is
specified). This method must return a String, and will always be invoked whenever an identifier of an instance of the
class is used alone (without following with the . operator). If we do not overwrite the toString() method, its
definition from the Object class will be used, which will print in the format package_name.type_name@hex_hash_code

In the body of constructors or methods of a class, private fields of an instance of the same class type received as
argument can be accessed directly. In other words, private members (not only fields) are private to the type, not to
an instance of that type.

<<Class finalizer>>

Besides class constructors, in Java we have class finalizers. A class finalizer defines a set of actions to be taken
before an instance of a class is deleted by the Java garbage collector. A typical example is to close a file stream
previously opened when the instance was created (free resources).

The garbage collector is invoked to free the memory occupied by a class instance, when we cannot longer refer to it.
We cannot call the Java garbage collector explicitly.

We can call a class's finalizer explicitly (provided its access modifiers allow so), but it will be called by the
garbage collector as well, just that we cannot know when. The finalizer always overwrite that of the class's superclass.

The syntax of a finalizer is equal to that of any normal method, but it must be called "finalize" eg.:
@Override
public void finalize() { ... }

We should NEVER use finalizers though. There are several drawbacks to finalizers. A preferred alternative is to make
our class implement the AutoCloseable interface and overwrite the close() method.
See https://www.baeldung.com/java-finalize for a though and clear explanation of finalizers.

In fact, finalize() method has been deprecated starting with Java 9 â€“ and will eventually be removed.

<<this>>

Whenever an object is instantiated, a special pointer to it is created. This pointer will be called "this" and can only
be used in the body of constructors, instance methods, default methods, instance initializers and instance variables
initializers, always of the class type of the object. It can't be used in static methods or static initializers,
because these exist only at class level.

When we directly access members of a class from the body of its constructors or methods, the compiler actually prepends
"this." to our call. We can do it explicitly as well, as when we pass to a constructor arguments named after some
fields of the class. Eg:

class ClassA{
    private int x;

    ClassA(int x) {this.x = x;}
}

This is an example of "hiding through nesting" or shadowing: the identifiers 'x' inside the constructor will be in an
"inner scope" and will "shadow" the identifier x in the class fields, which will be in an "outer scope". It may happen
between the body class and any of its methods body (a constructs is just a special method). In this case, access to
the identifier of the outer scope will be possible only using the keyword 'this'.

Constructors cannot be static. But constructors can access static members of a class and modify them if desired. A
common pattern is to have a constructor that increments a static counter of the class, so each time a new instance of
the class is created (new object) the counter is incremented, thus keeping track of the number of object of the class
instantiated so far. We can avoid new instances modifying a static field by declaring the field also 'final'.

The keyword 'this' allows for a very common pattern where we call different methods or constructors of a class in
cascade, to separately set some of its fields eg:
class ClassA {
    private int x;
    private int y;

    public ClassA setX(int x){
        this.x = x;
        return this;
    }
    public ClassB setY(int y){
        this.y = y;
        return this;
    }
}

//in the main()
ClassA ca = new ClassA()
System.out.println(ca.setX(3).setY(y));

When we use 'this' inside a constructor to call another constructor of the class, such instruction must be the first
in the constructor body. The following is a very common example, where we make converge the overloaded constructors of
a class into a single one that concentrates the logic. This also helps avoiding code duplication in the overloaded
constructors:

class MyTime{
    int h; int m; int s;

    public MyTime() {
        this (0, 0, 0);
    }
    public MyTime(int h) {
        this (h,0,0);
    }
    public MyTime(int h, int m) {
        this (h,m,0);
    }

    public MyTime(int h, int m, int s) {
        this.h = h;
        this.m = m;
        this.s = s;
    }
}

<<Array of objects>>
We declare an array of objects as

MyTime[] arr = {new MyTime(2), new MyTime(5,4), new MyTime()};

<<Nested classes>>

Java allows us to define classes inside other classes. Nested classes enable us to logically group classes that are
only used in one place, write more readable and maintainable code and increase encapsulation.

There are four types of nested classes in Java:
- static nested classes
- non-static nested classes (or inner class)
- Local classes
- Anonymous classes

<<Inner class>> from Horstmann 6.4.3

Access modifiers allowed for classes are either default or public. Both of theses give package visibility to classes.
Also, public accessor methods (getters and setters) will give access to private fields of a class to all other classes
in or outside the package.
What if we want to make a class only visible to another class?
What if we want to make a field of a class only accessible to another specific class?
What if we want to make clear that a class reference name belongs, or is "contextualized", to another class?

Inner classes allow these.
- Inner classes can be hidden from other classes in the same package.
- Inner classes can access private fields of its enclosing class, without using accessor methods.
- Anonymous inner classes are handy when we want to define callbacks (?) without writing a lot of code.

An inner class is created defining a usual class inside another normal class. This does not means that each
instance of the outer class will have an inner class instance as a field. Instead, in the body of the methods of the
outer class we will create an instance of the inner class as needed, invoking it's constructor with 'new'.

An outer class may define one or more inner classes in its body.

Each instance of an outer class may have one (or more?) instance of an inner class having a reference pointing to it.

An inner class will have direct access to private fields of the instance of the outer class that created it. In other
words, an inner class method gets to access both its own data fields and those of the outer object creating it. This
works because an object of an inner class always gets an implicit reference to the object of the outer class that
created it.

The outer class reference is set in every constructor of the inner class. The compiler modifies all inner class
constructors, adding a parameter for the outer class reference. Then upon every call to a constructor of the inner class
the compiler passes the 'this' reference to the instance of the outer class.

"Top level classes" (i.e. not nested classes) can only have access modifiers default or public (other modifiers are
abstract, final and strictfp). Inner classes in turn can also be private or protected. When they are private, only
methods of the outer class would be able to define references of its type.

Constructors of an inner class must always be invoked using a reference of the outer class. Inside methods of the outer
class however, this can be omitted as the compiler will automatically insert a 'this'. In other words, inside a method
of the outer class

MyInnerClass mic = this.new MyInnerClass();

is equivalent to

MyInnerClass mic = new MyInnerClass();



This is how the instance of the inner class gets the reference pointing to the instance of the outer class that creates
it. Thanks to this, we have that inside a method of the inner class, when accessing a field 'x' of the outer class,
the statement

if (x == 3)
    //...

is equivalent to

if (MyOuterClass.this.x == 3)
    //...

To avoid identifiers shadowing between the inner and the outer class, if the inner class also have a field called 'x',
we would do

if (this.x == MyOuterClass.this.x)
    //...

Outside the scope of the outer class, nevertheless, the reference to the outer class instance must always be
specified when instantiating an the inner class with new. Moreover, the inner class type name must be qualified with
the name of the outer class in this case. For example:

MyOuterClass moc = new MyOuterClass();
MyOuterClass.MyInnerClass mic = moc.new MyInnerClass();

This is because the inner class instance must know to which instance object of the outer class it will point.

In order to define a reference of an inner class outside the scope of its outer class, the inner class must be public.
In order to access the constructor of an inner class outside the scope of its outer class, the constructor must be
public.

Here is another example:

class Enclosing {
    private static final int x = 1;

    // an inner class accessing static members of its outer class directly
    public class Inner {
        public void printX() {
            System.out.println("value of x is: " + x);
        }
    }
}
//in the main()
Enclosing e = new Enclosing();
Enclosing.Inner ei = e.new Inner();
ei.printX();

An inner class can have static fields with the meaning we know. However, these must also be explicitly final.
An inner class cannot contain static methods or initializers.

An inner class is a thing of the compiler, not the JVM. Once compiled, an inner class will have a .class file name like
MyOuterClass$MyInnerClass.class. If we decompile it ( javap -private MyOuterClass\$MyInnerClass) we will see a field of
a reference to the outer class, as well as all constructor named after the .class file mentioned and having a parameter
of the outer class.

Moreover, if the compiler notice a method of the inner class is accessing a private field of the outer class, it will
automatically insert a public static getter method for the inner class to use it to get the private field.
We can see this method decompiling the outer class (javap -private TalkingClock). It will be named something like
access0$(OuterClass). This rises some security issues as a malicious .class file with the proper JVM instructions added
to the same package as the outer class, will be able to call this method as well, to get access to the private field.
We would need JVM instructions since access$0 is not a valid Java method name we can use in a normal .java file.

A private constructor in the inner class give place to other compiler creative artifacts (see Horstmann 6.4.3 end).

In my words: inner classes are classes whose instances' methods can access private fields of the instance of the outer
class that creates them. From the body of the outer class, the reference name and the constructor of the inner class
can be accessed directly. For access from the outside the body of the outer class, these things must have the proper
access modifiers as we know, and need to be qualified as mentioned above.

In general, all inner classes of an outer class are defined private, because they are meant to be used only from the
scope of the outer class. A typical use case is that of a public outer class with many private inner classes, each
accomplishing a particular task. Client code will create instances of the inner classes, or access their services,
only through public methods of the outer class. I think we can make the inner classes implement some public interfaces
so we can reference their objects outside the scope of the outer class.

Inner classes can also be declared inside an interface, in which case they will be implicitly static ???.
In general, Java supports nesting a class or an interface inside another class or interface. An inner class inside an
interface will be implicitly static. An inner interface inside a class or an interface will be implicitly static. In
general, when some member class or interface is static, it is called "nested", not inner.

<<Local inner classes>>
Private inner classes are accessible/visible only from the body of the outer class. We can restrict even more the access
and define the class inside a method of the outer class. This would be a local inner class. This make sense when an
inner class (reference name) is only used inside a method of the outer class.

Local inner classes do not support any access modifier and are accessible only from the scope of the method where they
are defined. Not even other methods of the same class can access the local inner class. They can't be static either.

Local inner classes have direct access to private fields of the enclosing class. For those fields of the outer class
that are static, it will suffice to access them qualifying with the outer class name.

Besides, local inner classes can also access the local variables of the method
where they are defined, including the method's parameters, provided they are effectively final. This is possible because
the compiler will insert in the body of the inner class, as final fields, a reference to the outer class as well as
all fields of the enclosing method the inner class happens to use. Then the compiler will set all constructors of the
local inner class to receive values for these fields as parameters as well, so it can set them upon a call to the a
constructor.

If the method enclosing the local class is static, the local class will not have access to non-static members of the
enclosing class (not tested by me yet).

If the method enclosing a local inner class is non-static, the local inner class cannot have a static initializer.

<<Anonymous inner classes>>
When using local inner classes we can go one step further: if we need to instantiate only one object of the local inner
class we don't even need to give the class a name. This gives place to anonymous classes, which actually are local
inner classes without a name (anonymous).

In Java we can instantiate objects from classes that implement one or more interfaces and/or extend one class. If the
class from which we want to instantiate the object will simply either implement one interface or extend another class,
and we only need one instance of such class, we actually don't need to give a name to this class. We can instantiate the
the object on-the-fly while defining the class body, using only the interface or class name.

The syntax is:
SuperTypeA obj = new SuperTypeB(construction parameters){
    //inner class methods and data
};

In the right member SuperTypeB will be either an interface or a super class. If it is an interface, we'll be
instantiating an object of a class without name that implements this interface. In this case we'll implement the
required methods in the body and will leave the "construction parameters" empty. If it is a superclass, we'll
be instantiating an object of a class without name extending it, an we'll pass the arguments for the constructor of
this superclass in the "constructor parameters".

In the left member, SuperTypeA is just an assignment compatible reference. Thus, it can be the same superclass or
interface we are using to define the inner class and instantiate an object from it.

We should pay attention to the differences between instantiating an object from a class and instantiating an object
from an anonymous class extending that class. The syntax is very similar:

Person queen = new Person("Mary"); // a Person object
Person queen = new Person("Mary") { . . . };// an object of an inner class extending Person

An equals() method should check for the differences between an object of a class and an object instantiated from a
subclass of this class; we should do:

if (getClass() != other.getClass()) return false;

For many years, Java programmers routinely used anonymous inner classes for event listeners and other callbacks.
Nowadays, you are better off using a lambda expression (?).

An anonymous inner class cannot have constructors because the name of a constructor must be the same as the name of a
class, and the class has no name. Instead, the construction parameters are given to the superclass constructor.

<<static inner class>>
If we want an inner class that doesn't keep a reference to the outer class, we can declare the inner class static.
Static inner classes are therefore independent of the outer class. We can create as many instances of a static inner
class as we want, without referring to any particular instance of the outer class. As a result, static inner classes
will have direct access to only static variables and methods of the outer class. To access non static members of the
outer class, an object of the outer class will need to be instantiated.

Static inner classes are called "nested classes" in Java.

From static or non static methods of the outer class, all members of the static inner class will be accessible (static
members using the inner class name, and non static members using an instance of the inner class).

From static or non static methods of the inner class, non static methods of the outer class will be accessible with an
object reference as usual, whereas static methods will be accessible only from static methods (of the inner class).

One case where we must use static inner classes is when a static method of an outer class wants to create an instance
of an inner class: in this case that inner class must be static as well. If the static method of the outer class returns
an instance of the static inner class, we are in front of a common use case.

From outside the outer class, static inner classes are like any other class. They just get their name prepended
(qualified with) the name of the outer class everywhere we use it, ie.:

MyOuterClass.MyInnerClass mioc;  //ok if both the outer and the static inner class are public
mioc = new MyOuterClass.MyInnerClass(); //ok if the constructor of the inner class is public

Therefore, we can use static inner classes just to make evident the "context" (the outer class) to which we mean that
class belong.

Static nested classes support all access modifiers default, private, public, and protected. Other modifiers they support
are abstract, final and strictfp.



<<Enum>>
When we declare an enum, we are declaring a new type as well as all the instances that that type will be allowed to
point to. We are also declaring the reference names that will point to those instances. The type will be called an enum
type, and the instances will be called enum constants. For these reasons, an enum is a special type of class, but in
must other aspects, an enum behaves as a normal class.

In the example below, the type is "MONTH" and the instances it may point to are referenced by MONTH.JANUARY, 
MONTH.FEBRUARY etc.

Enums are used to encapsulate sets of correlated constants (we don't put 'dog' in a set containing months names), while
allowing for a name for each of them. This greatly improve code
readability in those cases where otherwise an array of Strings, for example, would most probably be used. For example,
compare

String[] months = {"January", "February", "March"};
//in the main
String currentMonth = months[2]; // '2' is called a magic number.

vs

enum Months { //enum constants must always be written first
    JANUARY("Enero"),  //this will be the instances of the enum. We declare them and call the enum's constructor on the
    FEBRUARY("Febrero"),  //spot
    MARCH("Marzo"); //the ';' is needed only when we define a body for each enum constant,
                    // as in this example

    private final String spanishName;

    //constructor
    Months(String spanishName) {this.spanishName = spanishName}

    //instance initializers (example ?)
    //static initializers  (example ?)

    public String getSpanishName(){return spanishName;}
}
//in the main
Months currentMonth = Months.MARCH; // '2' is called a magic number.

Modifiers for enums can be public, protected, private, static and strictfp (same as classes?). Enums can implement
interfaces but cannot extend classes. Enums cannot be extended, except when there is at least one enum constant with
body ?.

Enums are implicitly static if nested as a member of another type.

Enum constants do not support any modifiers but annotations.
Enum constants can have a body with typical class members; the body will define an anonymous class.
Enum constants cannot be casted to int. Instead we use a method inherited method ordinal() (see below).

When used in switch statements, we use in the switch expression an enum reference type (identifier), and in the case
expressions the unqualified enum constant names.

For the compiler, enums are common classes that extend class Enum<E> of package java.lang. In the class of an enum,
the compiler will include the following static methods (see the decompiled of the .class of any enum)
- values(): Returns the enum constants in an array. Eg Months[] allMonths = Months.values();
   for (i: 0 .. allMonths.length )
        months[i].toString()
- valueOf(String): Given the name of an enum constant as a String (case sensitive), returns it.

In addition, thanks to the inheritance from  Enum<E>, each enum will have the instance methods:
- toString(): Calling .toString() on an enum reference, returns the pointed to enum constant name as a String.
- public final int ordinal(): returns the ordinal position of the current enum constant, according to its position in
  the list of enum constants, in the enum declaration. Zero start.
- public final int compareTo(E e): returns -1, 0, or 1 if the current enum constants has an ordinal position lower,
  equal, or greater than e, respectively. Both constants must be part of the same enumeration, of course.
- public final boolean equals(Object o): Compare the memory addresses of the current enum constant with that of o. Of
  course, both must be part of the same enum. It is equivalent to using ==.
- public final String name(): Returns the name, as a String, of the current enum constant, as it appears in the enum
  definition. Equivalent to toString().

To see how an enum is a common class extending Enum<T> for the compiler, we can examine the decompiled of the .class of
any enum.